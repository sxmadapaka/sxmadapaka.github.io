[{"title":"async和await","url":"/2024/02/23/async和await/","content":"\n**转载自知乎，原帖地址：https://zhuanlan.zhihu.com/p/172378607**\n\n## async 和 await 在干什么\n\n任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\n\n如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\n\n如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\n\n### async 起什么作用\n\n这个问题的关键在于，async 函数是怎么处理它的返回值的！\n\n我们当然希望它能直接通过 `return` 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\n\n```js\nasync function testAsync() {\n return \"hello async\";\n}\n \nconst result = testAsync();\nconsole.log(result);\n```\n\n看到输出就恍然大悟了——输出的是一个 Promise 对象。\n\n```abap\nc:\\var\\test> node --harmony_async_await .\nPromise { 'hello async' }\n```\n\n所以，async 函数返回的是一个 Promise 对象。从[文档](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样\n\n```js\ntestAsync().then(v => {\n console.log(v); // 输出 hello async\n});\n```\n\n\n\n现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n那么下一个关键点就在于 await 关键字了。\n\n### await 到底在等啥\n\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按[语法说明](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await)，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\n\n```js\nfunction getSomething() {\n return \"something\";\n}\n \nasync function testAsync() {\n return Promise.resolve(\"hello async\");\n}\n \nasync function test() {\n const v1 = await getSomething();\n const v2 = await testAsync();\n console.log(v1, v2);\n}\n \ntest();\n```\n\n### await 等到了要等的，然后呢\n\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n> 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n## async/await 帮我们干了啥\n\n### 作个简单的比较\n\n上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\n\n现在举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写\n\n```js\nfunction akeLongTime() {\n return new Promise(resolve => {\n setTimeout(() => resolve(\"long_time_value\"), 1000);\n });\n}\n \ntakeLongTime().then(v => {\n console.log(\"got\", v);\n});\n```\n\n如果改用 async/await 呢，会是这样\n\n```js\nfunction takeLongTime() {\n return new Promise(resolve => {\n setTimeout(() => resolve(\"long_time_value\"), 1000);\n });\n}\n \nasync function test() {\n const v = await takeLongTime();\n console.log(v);\n}\n \ntest();\n```\n\n眼尖的同学已经发现 `takeLongTime()` 没有申明为 `async`。实际上，`takeLongTime()` 本身就是返回的 Promise 对象，加不加 `async` 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\n\n又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？\n\n### async/await 的优势在于处理 then 链\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：\n\n```js\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n return new Promise(resolve => {\n setTimeout(() => resolve(n + 200), n);\n });\n}\n \nfunction step1(n) {\n console.log(`step1 with ${n}`);\n return takeLongTime(n);\n}\n \nfunction step2(n) {\n console.log(`step2 with ${n}`);\n return takeLongTime(n);\n}\n \nfunction step3(n) {\n console.log(`step3 with ${n}`);\n return takeLongTime(n);\n}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理\n\n```js\nfunction doIt() {\n console.time(\"doIt\");\n const time1 = 300;\n step1(time1)\n .then(time2 => step2(time2))\n .then(time3 => step3(time3))\n .then(result => {\n console.log(`result is ${result}`);\n console.timeEnd(\"doIt\");\n });\n}\n \ndoIt();\n \n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n```\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n\n```js\nasync function doIt() {\n console.time(\"doIt\");\n const time1 = 300;\n const time2 = await step1(time1);\n const time3 = await step2(time2);\n const result = await step3(time3);\n console.log(`result is ${result}`);\n console.timeEnd(\"doIt\");\n}\n \ndoIt();\n```\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n### 还有更酷的\n\n现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\n\n```js\nfunction step1(n) {\n console.log(`step1 with ${n}`);\n return takeLongTime(n);\n}\n \nfunction step2(m, n) {\n console.log(`step2 with ${m} and ${n}`);\n return takeLongTime(m + n);\n}\n \nfunction step3(k, m, n) {\n console.log(`step3 with ${k}, ${m} and ${n}`);\n return takeLongTime(k + m + n);\n}\n```\n\n这回先用 async/await 来写：\n\n```js\nasync function doIt() {\n console.time(\"doIt\");\n const time1 = 300;\n const time2 = await step1(time1);\n const time3 = await step2(time1, time2);\n const result = await step3(time1, time2, time3);\n console.log(`result is ${result}`);\n console.timeEnd(\"doIt\");\n}\n \ndoIt();\n \n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 800 = 300 + 500\n// step3 with 1800 = 300 + 500 + 1000\n// result is 2000\n// doIt: 2907.387ms\n```\n\n除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\n\n```js\nfunction doIt() {\n console.time(\"doIt\");\n const time1 = 300;\n step1(time1)\n .then(time2 => {\n return step2(time1, time2)\n .then(time3 => [time1, time2, time3]);\n })\n .then(times => {\n const [time1, time2, time3] = times;\n return step3(time1, time2, time3);\n })\n .then(result => {\n console.log(`result is ${result}`);\n console.timeEnd(\"doIt\");\n });\n}\n \ndoIt();\n```\n","tags":["前端,javascript"]},{"title":"我的第一篇博客","url":"/2024/02/21/我的第一篇博客/","content":"今天心血来潮搞了一个个人博客，用的hexo+github pages，一通抄别人的模板，最后效果还挺不错的。以后会不定期更新一些自己的学习笔记，虽然应该也不会有人看，但就当是给了我这懒狗一个学习和整理笔记的动力吧。（但不得不说纯静态的hexo要上传一个博客够麻烦的，而且md文件里还没法用表情，巨难受。。。。）\n","tags":["闲聊"]}]